import torch
import matplotlib.pyplot as plt
import numpy as np
def RLS(G, A, B):
    # ax+b=y
    losses=[]
    for g,a,b in zip(G, A, B):
        # loss = pow(g[:,1] - g[:,0] * a - b,2)
        loss=abs(g[:,1]-g[:,0]*a-b)
        losses.append(loss.sum())
    return losses

def update(var, lr):
    var.data = var.data - var.grad.data * lr
    var.grad.zero_()
    return var
G=[np.array([[ 6.        ,  3.        ,  0.21857923],
        [ 7.        ,  3.        ,  0.15300547],
        [ 5.        ,  4.        ,  0.13793103],
        [ 6.        ,  4.        ,  0.27586207],
        [ 7.        ,  4.        ,  0.29508197],
        [ 8.        ,  4.        ,  0.22950819],
        [ 9.        ,  4.        ,  0.16393442],
        [ 5.        ,  5.        ,  0.18390805],
        [ 6.        ,  5.        ,  0.3218391 ],
        [ 7.        ,  5.        ,  0.43715847],
        [ 8.        ,  5.        ,  0.3715847 ],
        [ 9.        ,  5.        ,  0.30601093],
        [10.        ,  5.        ,  0.24043716],
        [11.        ,  5.        ,  0.17486338],
        [12.        ,  5.        ,  0.10928962],
        [ 6.        ,  6.        ,  0.3678161 ],
        [ 7.        ,  6.        ,  0.50574714],
        [ 8.        ,  6.        ,  0.5136612 ],
        [ 9.        ,  6.        ,  0.44808742],
        [10.        ,  6.        ,  0.38251367],
        [11.        ,  6.        ,  0.3169399 ],
        [12.        ,  6.        ,  0.2513661 ],
        [13.        ,  6.        ,  0.18579236],
        [ 7.        ,  7.        ,  0.55172414],
        [ 8.        ,  7.        ,  0.6557377 ],
        [ 9.        ,  7.        ,  0.59016395],
        [10.        ,  7.        ,  0.52459013],
        [11.        ,  7.        ,  0.45901638],
        [12.        ,  7.        ,  0.39344263],
        [ 8.        ,  8.        ,  0.7356322 ],
        [ 9.        ,  8.        ,  0.73224044],
        [10.        ,  8.        ,  0.6666667 ],
        [11.        ,  8.        ,  0.6010929 ],
        [ 9.        ,  9.        ,  0.87431693],
        [10.        ,  9.        ,  0.8087432 ]], dtype=np.float32),
 np.array([[14.        ,  6.        ,  0.12021858],
        [13.        ,  7.        ,  0.32786885],
        [14.        ,  7.        ,  0.26229507],
        [15.        ,  7.        ,  0.19672132],
        [16.        ,  7.        ,  0.13114753],
        [12.        ,  8.        ,  0.5355191 ],
        [13.        ,  8.        ,  0.46994534],
        [14.        ,  8.        ,  0.4043716 ],
        [15.        ,  8.        ,  0.3387978 ],
        [16.        ,  8.        ,  0.21111111],
        [11.        ,  9.        ,  0.7431694 ],
        [14.        ,  9.        ,  0.42222223],
        [10.        , 10.        ,  0.9       ],
        [11.        , 10.        ,  0.76666665],
        [12.        , 10.        ,  0.6333333 ],
        [13.        , 10.        ,  0.5       ],
        [14.        , 10.        ,  0.36666667],
        [15.        , 10.        ,  0.23333333],
        [16.        , 10.        ,  0.1       ],
        [12.        , 11.        ,  0.5777778 ],
        [13.        , 11.        ,  0.44444445],
        [14.        , 11.        ,  0.31111112],
        [15.        , 11.        ,  0.17777778],
        [12.        , 12.        ,  0.5222222 ],
        [13.        , 12.        ,  0.3888889 ],
        [15.        , 12.        ,  0.12222222],
        [13.        , 13.        ,  0.33333334],
        [14.        , 13.        ,  0.2       ],
        [14.        , 14.        ,  0.14444445]], dtype=np.float32)
 ]
G=[g[:,[0,2]] for g in G]
gm=[np.max(g,0) for g in G]
G=[g/np.max(g,0) for g in G]
# G=np.array([5,6,7,5,9,4,11,3]).reshape(-1,2)
# G[:,0]=G[:,0]/np.max(G[:,0])
# G[:,1]=G[:,1]/np.max(G[:,1])
# G=[G]
N=sum([len(g) for g in G])
num_planes=len(G)
A = torch.zeros(num_planes)
A.requires_grad=True
B = torch.zeros(num_planes, requires_grad=True)
G = [torch.FloatTensor(g) for g in G]
i=0
lr=0.1
while 1:
    while i <1000:
        i+=1
        losses = RLS(G, A, B)
        res = sum(losses) / N
        res.backward()
        for d in [A, B]:
            update(d, lr)
    with torch.no_grad():
        delta = 0.5
        x = np.arange(0, 20., delta)
        # mark=['_','|']
        for i in range(len(G)):
            y = (A[i].data.numpy()/gm[i][0]*x+B[i].data.numpy())*gm[i][1]
            plt.plot(x,y)
            plt.scatter(G[i][:,0]*gm[i][0],G[i][:,1]*gm[i][1])
        plt.show()
        pp=1